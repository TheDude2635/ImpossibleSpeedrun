<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Segway Adventure</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            text-align: center;
            font-family: 'Roboto', Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            max-height: 600px;
            display: block;
            margin: 0 auto;
            border: 1px solid black;
        }
        #startScreen, #gameOverScreen, #leaderboardScreen, #namePrompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            text-align: center;
            z-index: 10;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #6e8efb, #a777e3);
            color: white;
            transition: transform 0.2s, background 0.3s;
        }
        button:hover {
            transform: scale(1.05);
            background: linear-gradient(135deg, #a777e3, #6e8efb);
        }
        select, input {
            padding: 8px;
            font-size: 16px;
            margin: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        #leaderboardScreen {
            width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #leaderboardScreen h1 {
            font-size: 28px;
            margin-bottom: 15px;
            color: #333;
        }
        .leaderboard-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .difficulty-filter {
            display: flex;
            gap: 15px;
        }
        .difficulty-filter label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            color: #555;
        }
        .difficulty-filter input[type="checkbox"] {
            accent-color: #6e8efb;
        }
        table {
            width: 90%;
            margin: 0 auto 15px;
            border-collapse: collapse;
            background-color: #fff;
            border-radius: 10px;
            overflow: hidden;
        }
        th {
            background: linear-gradient(135deg, #6e8efb, #a777e3);
            color: white;
            padding: 12px;
            font-size: 16px;
        }
        td {
            padding: 10px;
            font-size: 14px;
            color: #333;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .joystick {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            z-index: 20;
        }
        .joystick-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        @media (max-width: 600px) {
            .joystick {
                display: block;
            }
            canvas {
                width: 100vw;
                height: 80vh;
            }
            #leaderboardScreen {
                width: 90%;
            }
            .leaderboard-controls {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="startScreen" style="display: none;">
        <h1>Segway Adventure</h1>
        <p>Vælg sværhedsgrad:</p>
        <select id="difficulty">
            <option value="easy">Easy</option>
            <option value="normal">Normal</option>
            <option value="hard">Hard</option>
            <option value="speedrun">Speed Run</option>
        </select>
        <p>Vælg level:</p>
        <select id="levelSelect">
            <option value="1">Level 1: Himmel</option>
            <option value="2">Level 2: Skyer</option>
            <option value="3">Level 3: Mount Everest</option>
            <option value="4">Level 4: Byen</option>
            <option value="5">Level 5: Vand</option>
            <option value="6">Level 6: Under Jorden</option>
            <option value="7">Level 7: Helvede</option>
        </select>
        <br>
        <button onclick="startGame()">Start Spil</button>
        <button onclick="startFullRun()">Full Run</button>
        <button onclick="showLeaderboard()">Vis Leaderboard</button>
    </div>
    <div id="gameOverScreen" style="display: none;">
        <h1>Game Over</h1>
        <p>Din tid: <span id="finalTime">0</span>s</p>
        <button onclick="restartGame()">Genstart</button>
        <button onclick="backToMenu()">Tilbage til Menu</button>
    </div>
    <div id="leaderboardScreen" style="display: none;">
        <h1>Leaderboard</h1>
        <div class="leaderboard-controls">
            <select id="leaderboardSelect">
                <option value="full">Full Run</option>
                <option value="1">Level 1</option>
                <option value="2">Level 2</option>
                <option value="3">Level 3</option>
                <option value="4">Level 4</option>
                <option value="5">Level 5</option>
                <option value="6">Level 6</option>
                <option value="7">Level 7</option>
            </select>
            <div class="difficulty-filter">
                <label><input type="checkbox" id="filterEasy" checked> Easy <span style="color: green;">■</span></label>
                <label><input type="checkbox" id="filterNormal" checked> Normal <span style="color: blue;">■</span></label>
                <label><input type="checkbox" id="filterHard" checked> Hard <span style="color: red;">■</span></label>
                <label><input type="checkbox" id="filterSpeedrun" checked> Speedrun <span style="color: yellow;">■</span></label>
            </div>
        </div>
        <table id="leaderboardTable">
            <tr><th>Navn</th><th>Sværhedsgrad</th><th>Tid (s)</th><th>Dødsfald (Full Run)</th></tr>
        </table>
        <button id="showMore" onclick="showMoreEntries()">Se flere</button>
        <button onclick="backToMenu()">Tilbage til Menu</button>
    </div>
    <div id="namePrompt" style="display: block;">
        <h1>Velkommen!</h1>
        <p>Indtast dit navn:</p>
        <input type="text" id="playerNameInput" placeholder="Dit navn">
        <br>
        <button id="continueButton" onclick="savePlayerName()">Fortsæt</button>
    </div>
    <div class="joystick" id="joystick">
        <div class="joystick-inner" id="joystickInner"></div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const leaderboardScreen = document.getElementById('leaderboardScreen');
        const namePrompt = document.getElementById('namePrompt');
        const joystick = document.getElementById('joystick');
        const joystickInner = document.getElementById('joystickInner');

        const player = {
            x: 400,
            y: 500,
            width: 40,
            height: 60,
            speed: 5,
            baseSpeed: 5,
            jumping: false,
            jumpCount: 0,
            invincibilityTimer: 0,
            jumpCooldown: 0,
            rotation: 0,
            energy: 100,
            level: 1,
            lives: 3,
            fullRun: false,
            fullRunTimer: 0,
            difficultyIndex: 0,
            collisionBlink: 0,
            deaths: 0,
            name: null
        };

        let obstacles = [];
        let projectiles = [];
        let walls = [];
        let particles = [];
        let keys = {};
        let gameStarted = false;
        let gameOver = false;
        let difficultyMultiplier = 1;
        let energyRegenTimer = 0;
        let levelSpeed = 2;
        let timeElapsed = 0;
        let speedBoostActive = false;
        let collisionCooldown = 0;
        let backgroundOffset = 0;
        let animationFrame = 0;
        const difficulties = ['easy', 'normal', 'hard', 'speedrun'];
        let levelTimes = JSON.parse(localStorage.getItem('levelTimes')) || {};
        let fullRunTimes = JSON.parse(localStorage.getItem('fullRunTimes')) || [];
        let leaderboardLimit = 10;

        window.onload = function() {
            if (!sessionStorage.getItem('playerName') || sessionStorage.getItem('playerName').trim() === '') {
                namePrompt.style.display = 'block';
                startScreen.style.display = 'none';
            } else {
                player.name = sessionStorage.getItem('playerName');
                namePrompt.style.display = 'none';
                startScreen.style.display = 'block';
            }
        };

        function savePlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim();
            if (name) {
                player.name = name;
                sessionStorage.setItem('playerName', name);
                namePrompt.style.display = 'none';
                startScreen.style.display = 'block';
            } else {
                alert('Indtast venligst et navn!');
            }
        }

        document.getElementById('playerNameInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') savePlayerName();
        });

        let joystickActive = false;
        let joystickX = 0;
        let joystickY = 0;

        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            handleJoystick(e.touches[0]);
        });

        joystick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickActive) handleJoystick(e.touches[0]);
        });

        joystick.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickActive = false;
            joystickInner.style.left = '50%';
            joystickInner.style.top = '50%';
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            keys['ArrowUp'] = false;
            keys['ArrowDown'] = false;
            keys[' '] = false;
        });

        function handleJoystick(touch) {
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const touchX = touch.clientX;
            const touchY = touch.clientY;

            const dx = touchX - centerX;
            const dy = touchY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = rect.width / 2 - 20;

            if (distance < 20) {
                keys[' '] = true;
                keys['ArrowLeft'] = false;
                keys['ArrowRight'] = false;
                keys['ArrowUp'] = false;
                keys['ArrowDown'] = false;
                joystickInner.style.left = '50%';
                joystickInner.style.top = '50%';
            } else {
                keys[' '] = false;
                const angle = Math.atan2(dy, dx);
                const limitedDistance = Math.min(distance, maxDistance);
                joystickX = limitedDistance * Math.cos(angle);
                joystickY = limitedDistance * Math.sin(angle);

                joystickInner.style.left = `${50 + (joystickX / maxDistance) * 40}%`;
                joystickInner.style.top = `${50 + (joystickY / maxDistance) * 40}%`;

                keys['ArrowLeft'] = dx < -20;
                keys['ArrowRight'] = dx > 20;
                keys['ArrowUp'] = dy < -20;
                keys['ArrowDown'] = dy > 20;
            }
        }

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            keys[e.code] = true;
            if (e.key === 'r' || e.key === 'R') restartGame();
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            keys[e.code] = false;
        });

        function startGame() {
            const difficulty = document.getElementById('difficulty').value;
            setDifficulty(difficulty);
            player.level = parseInt(document.getElementById('levelSelect').value);
            player.fullRun = false;
            resetPlayer();
            generateObstacles();
            startScreen.style.display = 'none';
            gameStarted = true;
            update();
        }

        function startFullRun() {
            player.fullRun = true;
            player.level = 1;
            player.difficultyIndex = 0;
            setDifficulty(difficulties[player.difficultyIndex]);
            player.lives = 3;
            player.fullRunTimer = 0;
            player.deaths = 0;
            resetPlayer();
            generateObstacles();
            startScreen.style.display = 'none';
            gameStarted = true;
            update();
        }

        function setDifficulty(diff) {
            if (diff === 'easy') difficultyMultiplier = 1;
            else if (diff === 'normal') difficultyMultiplier = 1.5;
            else if (diff === 'hard') difficultyMultiplier = 2;
            else if (diff === 'speedrun') difficultyMultiplier = 2.5;
        }

        function resetPlayer() {
            player.x = 400;
            player.y = 500;
            player.energy = 100;
            player.jumpCount = 0;
            player.jumping = false;
            player.invincibilityTimer = 0;
            player.jumpCooldown = 0;
            player.rotation = 0;
            timeElapsed = 0;
            obstacles = [];
            projectiles = [];
            walls = [];
            particles = [];
            gameOver = false;
            collisionCooldown = 0;
            player.collisionBlink = 0;
        }

        function restartGame() {
            gameOver = false;
            gameOverScreen.style.display = 'none';
            resetPlayer();
            generateObstacles();
            update();
        }

        function backToMenu() {
            gameOver = false;
            gameStarted = false;
            gameOverScreen.style.display = 'none';
            leaderboardScreen.style.display = 'none';
            startScreen.style.display = 'block';
        }

        function showLeaderboard() {
            startScreen.style.display = 'none';
            leaderboardScreen.style.display = 'block';
            leaderboardLimit = 10;
            updateLeaderboard();

            document.getElementById('leaderboardSelect').onchange = updateLeaderboard;
            document.getElementById('filterEasy').onchange = updateLeaderboard;
            document.getElementById('filterNormal').onchange = updateLeaderboard;
            document.getElementById('filterHard').onchange = updateLeaderboard;
            document.getElementById('filterSpeedrun').onchange = updateLeaderboard;
        }

        function showMoreEntries() {
            if (leaderboardLimit === 10) leaderboardLimit = 50;
            else if (leaderboardLimit === 50) leaderboardLimit = 100;
            updateLeaderboard();
        }

        function updateLeaderboard() {
            const selectedLevel = document.getElementById('leaderboardSelect').value;
            const filterEasy = document.getElementById('filterEasy').checked;
            const filterNormal = document.getElementById('filterNormal').checked;
            const filterHard = document.getElementById('filterHard').checked;
            const filterSpeedrun = document.getElementById('filterSpeedrun').checked;

            const table = document.getElementById('leaderboardTable');
            table.innerHTML = '<tr><th>Navn</th><th>Sværhedsgrad</th><th>Tid (s)</th><th>Dødsfald (Full Run)</th></tr>';

            let entries = [];
            if (selectedLevel === 'full') {
                entries = fullRunTimes.map(entry => ({
                    name: entry.name,
                    difficulty: 'Full Run',
                    time: entry.time,
                    deaths: entry.deaths
                }));
            } else {
                for (let diff of difficulties) {
                    if ((diff === 'easy' && filterEasy) ||
                        (diff === 'normal' && filterNormal) ||
                        (diff === 'hard' && filterHard) ||
                        (diff === 'speedrun' && filterSpeedrun)) {
                        const key = `${selectedLevel}-${diff}`;
                        const entry = levelTimes[key];
                        if (entry) {
                            entries.push({
                                name: entry.name,
                                difficulty: diff,
                                time: entry.time,
                                deaths: '-'
                            });
                        }
                    }
                }
            }

            entries.sort((a, b) => a.time - b.time);
            const limitedEntries = entries.slice(0, leaderboardLimit);

            if (limitedEntries.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="4">Ingen tider registreret endnu</td>';
                table.appendChild(row);
            } else {
                limitedEntries.forEach(entry => {
                    const row = document.createElement('tr');
                    let color = '';
                    if (entry.difficulty === 'easy') color = 'green';
                    else if (entry.difficulty === 'normal') color = 'blue';
                    else if (entry.difficulty === 'hard') color = 'red';
                    else if (entry.difficulty === 'speedrun') color = 'yellow';
                    else color = 'black';
                    row.innerHTML = `
                        <td>${entry.name}</td>
                        <td style="color: ${color}">${entry.difficulty}</td>
                        <td>${entry.time.toFixed(2)}</td>
                        <td>${entry.deaths}</td>
                    `;
                    table.appendChild(row);
                });
            }

            const showMoreButton = document.getElementById('showMore');
            showMoreButton.style.display = entries.length > leaderboardLimit ? 'block' : 'none';
            showMoreButton.textContent = leaderboardLimit === 10 ? 'Se top 50' : 'Se top 100';
        }

        function generateObstacles() {
            obstacles = [];
            projectiles = [];
            walls = [];
            const baseObstacles = [];
            let levelSpeedMultiplier = 1 + (player.level - 1) * 0.2;
            levelSpeed = 2 * levelSpeedMultiplier;

            if (player.level !== 5 && player.level !== 6) {
                walls.push(
                    { x: 0, y: 0, width: 30, height: canvas.height, type: 'Wall', size: 'large' },
                    { x: canvas.width - 30, y: 0, width: 30, height: canvas.height, type: 'Wall', size: 'large' }
                );
            }

            if (player.level === 1) { // Himmel
                let yPos = -50;
                for (let i = 0; i < 25; i++) {
                    let xPos1 = 100 + (i % 3) * 200;
                    let xPos2 = 150 + ((i + 1) % 3) * 200;
                    let xPos3 = 200 + ((i + 2) % 3) * 200;
                    baseObstacles.push(
                        { x: xPos1, y: yPos, width: 80, height: 50, type: 'Angel', size: 'large', moving: true, speedX: 1 },
                        { x: xPos2, y: yPos - 150, width: 30, height: 20, type: 'Harp', size: 'small' },
                        { x: xPos3, y: yPos - 300, width: 100, height: 60, type: 'Gate', size: 'large' }
                    );
                    yPos -= 450;
                }
            } else if (player.level === 2) { // Skyer
                let yPos = -50;
                for (let i = 0; i < 25; i++) {
                    let xPos1 = 100 + (i % 3) * 200;
                    let xPos2 = 150 + ((i + 1) % 3) * 200;
                    let xPos3 = 200 + ((i + 2) % 3) * 200;
                    baseObstacles.push(
                        { x: xPos1, y: yPos, width: 30, height: 20, type: 'Bird', size: 'small', moving: true, speedX: 2 },
                        { x: xPos2, y: yPos - 150, width: 60, height: 40, type: 'Meteor', size: 'large', moving: true, speedX: 1.5, speedY: 1.5 },
                        { x: xPos3, y: yPos - 300, width: 100, height: 50, type: 'Airplane', size: 'large' }
                    );
                    yPos -= 450;
                }
            } else if (player.level === 3) { // Mount Everest
                let yPos = -50;
                for (let i = 0; i < 25; i++) {
                    let xPos1 = 100 + (i % 3) * 200;
                    let xPos2 = 150 + ((i + 1) % 3) * 200;
                    let xPos3 = 200 + ((i + 2) % 3) * 200;
                    baseObstacles.push(
                        { x: xPos1, y: yPos, width: 80, height: 50, type: 'Rock', size: 'large' },
                        { x: xPos2, y: yPos - 150, width: 50, height: 30, type: 'Tent', size: 'medium' },
                        { x: xPos3, y: yPos - 300, width: 40, height: 60, type: 'Climber', size: 'small', moving: true, speedX: 1 }
                    );
                    yPos -= 450;
                }
            } else if (player.level === 4) { // Byen
                let yPos = -50;
                for (let i = 0; i < 25; i++) {
                    let xPos1 = 100 + (i % 3) * 200;
                    let xPos2 = 150 + ((i + 1) % 3) * 200;
                    let xPos3 = 200 + ((i + 2) % 3) * 200;
                    baseObstacles.push(
                        { x: xPos1, y: yPos, width: 100, height: 50, type: 'Car', size: 'large', moving: true, speedX: 3 },
                        { x: xPos2, y: yPos - 150, width: 20, height: 40, type: 'Pedestrian', size: 'small', moving: true, speedX: 1 },
                        { x: xPos3, y: yPos - 300, width: 60, height: 80, type: 'Building', size: 'large' }
                    );
                    yPos -= 450;
                }
            } else if (player.level === 5) { // Vand
                let yPos = -200;
                for (let i = 0; i < 25; i++) {
                    let xPos1 = 100 + (i % 3) * 200;
                    let xPos2 = 150 + ((i + 1) % 3) * 200;
                    baseObstacles.push(
                        { x: xPos1, y: yPos, width: 30, height: 20, type: 'Fish', size: 'small', moving: true, speedX: 2 },
                        { x: xPos2, y: yPos - 150, width: 90, height: 60, type: 'Whale', size: 'large', moving: true, speedX: 1.5 }
                    );
                    yPos -= 300;
                }
            } else if (player.level === 6) { // Under Jorden
                let pathWidth;
                switch (difficultyMultiplier) {
                    case 1: pathWidth = 200; break; // Easy
                    case 1.5: pathWidth = 150; break; // Normal
                    case 2: pathWidth = 100; break; // Hard
                    default: pathWidth = 80; break; // Speedrun
                }
                let centerX = canvas.width / 2;
                let yPos = -50;
                let amplitude = 300;
                let frequency = 0.1; // Mere snoet
                let stoneLineCount = difficultyMultiplier === 1 ? 1 : Math.floor(difficultyMultiplier * 2);
                let stoneLineAdded = 0;

                for (let i = 0; i < 90; i++) {
                    let offset = amplitude * Math.sin(i * frequency * Math.PI);
                    centerX = (canvas.width / 2) + offset;
                    if (centerX - pathWidth < 0) centerX = pathWidth;
                    if (centerX + pathWidth > canvas.width) centerX = canvas.width - pathWidth;
                    walls.push(
                        { x: 0, y: yPos, width: centerX - pathWidth, height: 30, type: 'Wall', size: 'large' },
                        { x: centerX + pathWidth, y: yPos, width: canvas.width - (centerX + pathWidth), height: 30, type: 'Wall', size: 'large' }
                    );
                    if (difficultyMultiplier === 1 && (i === 20 || i === 60)) {
                        let stoneX = centerX - pathWidth / 4;
                        obstacles.push({
                            x: stoneX,
                            y: yPos,
                            width: 40,
                            height: 20,
                            type: 'Rock',
                            size: 'small',
                            speed: levelSpeed
                        });
                    } else if (difficultyMultiplier > 1 && i % 10 === 0) {
                        let stoneX = centerX - pathWidth / 4;
                        obstacles.push({
                            x: stoneX,
                            y: yPos,
                            width: 40,
                            height: 20,
                            type: 'Rock',
                            size: 'small',
                            speed: levelSpeed
                        });
                    }
                    if (stoneLineAdded < stoneLineCount && i === Math.floor(90 / (stoneLineCount + 1)) * (stoneLineAdded + 1)) {
                        let startX = centerX - pathWidth;
                        for (let x = startX; x < centerX + pathWidth; x += 15) {
                            obstacles.push({
                                x: x,
                                y: yPos,
                                width: 10,
                                height: 10,
                                type: 'StoneDots',
                                size: 'small',
                                speed: levelSpeed
                            });
                        }
                        stoneLineAdded++;
                    }
                    yPos -= 50; // Mindre "lige ud" stykker
                }
            } else if (player.level === 7) { // Helvede
                let yPos = -50;
                for (let i = 0; i < 15; i++) {
                    let xPos1 = 100 + (i % 3) * 200;
                    let xPos2 = 150 + ((i + 1) % 3) * 200;
                    let xPos3 = 200 + ((i + 2) % 3) * 200;
                    baseObstacles.push(
                        { x: xPos1, y: yPos, width: 30, height: 20, type: 'Demon', size: 'small', shooting: true, shootType: 'horizontal' },
                        { x: xPos2, y: yPos - 200, width: 80, height: 50, type: 'Devil', size: 'large', shooting: true, shootType: 'diagonal' },
                        { x: xPos3, y: yPos - 400, width: 50, height: 30, type: 'Flame', size: 'medium' }
                    );
                    yPos -= 600;
                }
            }

            for (let i = 0; i < baseObstacles.length; i++) {
                obstacles.push({ ...baseObstacles[i], speed: levelSpeed });
                if (baseObstacles[i].type !== 'Wall') {
                    for (let j = 0; j < Math.floor(difficultyMultiplier); j++) {
                        let newX = baseObstacles[i].x + (j + 1) * 50;
                        obstacles.push({
                            x: newX,
                            y: baseObstacles[i].y - (j + 1) * 30,
                            width: baseObstacles[i].width,
                            height: baseObstacles[i].height,
                            type: baseObstacles[i].type,
                            size: baseObstacles[i].size,
                            speed: levelSpeed,
                            moving: baseObstacles[i].moving,
                            speedX: baseObstacles[i].speedX,
                            shooting: baseObstacles[i].shooting,
                            shootType: baseObstacles[i].shootType
                        });
                    }
                }
            }
            timeElapsed = 0;
        }

        function update() {
            if (!gameStarted || gameOver) return;

            speedBoostActive = false;
            let speedModifier = 1;
            if (keys['ArrowUp'] || keys['KeyW']) {
                speedModifier = 1.25;
                speedBoostActive = true;
            } else if (keys['ArrowDown'] || keys['KeyS']) {
                speedModifier = 0.25;
            }

            player.speed = player.baseSpeed * speedModifier;
            if (keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed;
            if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;

            if ((keys[' '] || keys['Space']) && player.energy >= 100 && player.jumpCooldown <= 0 && !player.jumping) {
                player.jumping = true;
                player.jumpCount++;
                player.invincibilityTimer = 1;
                player.rotation = 0;
                player.energy = 0;
                for (let i = 0; i < 10; i++) {
                    particles.push({
                        x: player.x + player.width / 2,
                        y: player.y + player.height,
                        size: 2 + i % 3,
                        speedX: (i % 2 - 0.5) * 2,
                        speedY: i % 3,
                        life: 0.5
                    });
                }
            }

            if (player.invincibilityTimer > 0) {
                player.invincibilityTimer -= 1 / 60;
                player.rotation += (2 * Math.PI) / 60;
                if (player.invincibilityTimer <= 0) {
                    player.jumping = false;
                    player.invincibilityTimer = 0;
                    player.rotation = 0;
                    player.jumpCount = 0;
                    player.jumpCooldown = 2;
                }
            }

            if (player.jumpCooldown > 0) {
                player.jumpCooldown -= 1 / 60;
            }

            if (player.level === 5) {
                if (player.x < 0) player.x = 0;
                if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
            } else {
                if (player.x < 30) player.x = 30;
                if (player.x > canvas.width - player.width - 30) player.x = canvas.width - player.width - 30;
            }

            energyRegenTimer += 1 / 60;
            if (energyRegenTimer >= 2) {
                player.energy = 100;
                energyRegenTimer = 0;
            }

            let allObstaclesPassed = true;
            let obstaclesToRemove = [];
            obstacles.forEach((obs, index) => {
                obs.y += obs.speed * speedModifier;
                if (obs.moving) {
                    obs.x += (obs.speedX || 2) * speedModifier;
                    if (obs.x <= 30 || obs.x >= canvas.width - obs.width - 30) obs.speedX = -obs.speedX;
                }
                if (obs.y + obs.height > 0 && obs.y < canvas.height) allObstaclesPassed = false;
                if (obs.y > canvas.height) obstaclesToRemove.push(index);

                if (obs.shooting && timeElapsed % 3 < 1 / 60) {
                    if (obs.shootType === 'horizontal') {
                        projectiles.push({ x: obs.x, y: obs.y, width: 10, height: 5, speedX: -5, speedY: 0 });
                    } else if (obs.shootType === 'diagonal') {
                        let directionX = player.x < obs.x ? -3 : 3;
                        projectiles.push({ x: obs.x, y: obs.y, width: 10, height: 5, speedX: directionX, speedY: 3 });
                    }
                }
                if (player.invincibilityTimer <= 0 && collisionCooldown <= 0 &&
                    player.x < obs.x + obs.width && player.x + player.width > obs.x &&
                    player.y < obs.y + obs.height && player.y + player.height > obs.y) {
                    handleCollision();
                }
            });

            obstaclesToRemove.reverse().forEach(index => obstacles.splice(index, 1));

            let wallsToRemove = [];
            walls.forEach((wall, index) => {
                wall.y += levelSpeed * speedModifier;
                if (wall.y + wall.height > 0 && wall.y < canvas.height) allObstaclesPassed = false;
                if (wall.y > canvas.height) wallsToRemove.push(index);
                if (player.invincibilityTimer <= 0 && collisionCooldown <= 0 &&
                    player.x < wall.x + wall.width && player.x + player.width > wall.x &&
                    player.y < wall.y + wall.height && player.y + player.height > wall.y) {
                    handleCollision();
                }
            });

            wallsToRemove.reverse().forEach(index => walls.splice(index, 1));

            let projectilesToRemove = [];
            projectiles.forEach((proj, index) => {
                proj.x += proj.speedX * speedModifier; // Slowmotion påvirker skud
                proj.y += proj.speedY * speedModifier;
                if (proj.x < 0 || proj.x > canvas.width || proj.y > canvas.height) {
                    projectilesToRemove.push(index);
                }
                if (player.invincibilityTimer <= 0 && collisionCooldown <= 0 &&
                    player.x < proj.x + proj.width && player.x + player.width > proj.x &&
                    player.y < proj.y + proj.height && player.y + player.height > proj.y) {
                    handleCollision();
                }
            });

            projectilesToRemove.reverse().forEach(index => projectiles.splice(index, 1));

            particles = particles.filter(p => {
                p.x += p.speedX;
                p.y += p.speedY;
                p.life -= 1 / 60;
                return p.life > 0;
            });

            if (collisionCooldown > 0) {
                collisionCooldown -= 1 / 60;
                player.collisionBlink = Math.sin(Date.now() * 0.01) > 0 ? 1 : 0;
            } else {
                player.collisionBlink = 0;
            }

            timeElapsed += 1 / 60;
            if (player.fullRun) player.fullRunTimer += 1 / 60;
            if (allObstaclesPassed && obstacles.length === 0 && walls.length === 0) {
                const timeKey = `${player.level}-${difficulties[player.difficultyIndex]}`;
                if (!levelTimes[timeKey] || timeElapsed < levelTimes[timeKey].time) {
                    levelTimes[timeKey] = { name: player.name, time: timeElapsed };
                    localStorage.setItem('levelTimes', JSON.stringify(levelTimes));
                }

                if (player.fullRun) {
                    player.level++;
                    if (player.level > 7) {
                        player.level = 1;
                        player.difficultyIndex++;
                        if (player.difficultyIndex >= difficulties.length) {
                            fullRunTimes.push({ name: player.name, time: player.fullRunTimer, deaths: player.deaths });
                            localStorage.setItem('fullRunTimes', JSON.stringify(fullRunTimes));
                            alert(`Full Run gennemført! Tid: ${player.fullRunTimer.toFixed(2)}s, Dødsfald: ${player.deaths}`);
                            gameOver = true;
                            document.getElementById('finalTime').innerText = player.fullRunTimer.toFixed(2);
                            gameOverScreen.style.display = 'block';
                            return;
                        }
                        setDifficulty(difficulties[player.difficultyIndex]);
                    }
                    generateObstacles();
                } else {
                    alert(`Level gennemført! Tid: ${timeElapsed.toFixed(2)}s`);
                    gameOver = true;
                    document.getElementById('finalTime').innerText = timeElapsed.toFixed(2);
                    gameOverScreen.style.display = 'block';
                }
            }

            backgroundOffset += levelSpeed * speedModifier * 0.5;
            if (backgroundOffset > canvas.height) backgroundOffset -= canvas.height;
            animationFrame++;

            draw();
            requestAnimationFrame(update);
        }

        function handleCollision() {
            if (player.fullRun) {
                player.lives--;
                player.deaths++;
                if (player.lives <= 0) {
                    gameOver = true;
                    document.getElementById('finalTime').innerText = player.fullRunTimer.toFixed(2);
                    gameOverScreen.style.display = 'block';
                } else {
                    player.x = 400;
                    player.y = 500;
                    player.energy = 100;
                    player.jumping = false;
                    player.jumpCount = 0;
                    player.invincibilityTimer = 0;
                    player.jumpCooldown = 0;
                    player.rotation = 0;
                    timeElapsed = 0;
                    projectiles = [];
                    collisionCooldown = 1;
                    generateObstacles();
                }
            } else {
                gameOver = true;
                document.getElementById('finalTime').innerText = timeElapsed.toFixed(2);
                gameOverScreen.style.display = 'block';
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            switch (player.level) {
                case 1: gradient.addColorStop(0, 'lightblue'); gradient.addColorStop(1, 'white'); break;
                case 2: gradient.addColorStop(0, 'skyblue'); gradient.addColorStop(1, 'lightgray'); break;
                case 3: gradient.addColorStop(0, 'lightgray'); gradient.addColorStop(1, 'white'); break;
                case 4: gradient.addColorStop(0, 'green'); gradient.addColorStop(1, 'lightgreen'); break;
                case 5: gradient.addColorStop(0, 'blue'); gradient.addColorStop(1, 'darkblue'); break;
                case 6: gradient.addColorStop(0, 'gray'); gradient.addColorStop(1, 'darkgray'); break;
                case 7: gradient.addColorStop(0, 'red'); gradient.addColorStop(1, 'darkred'); break;
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Baggrundselementer
            if (player.level === 1) { // Skyer
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                for (let i = 0; i < 5; i++) {
                    let cloudY = (backgroundOffset * 0.2 + i * 150) % canvas.height;
                    ctx.beginPath();
                    ctx.arc(100 + i * 150, cloudY, 40, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (player.level === 5) { // Bølger
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                for (let i = 0; i < 5; i++) {
                    let waveY = (backgroundOffset + i * 50) % canvas.height;
                    ctx.beginPath();
                    ctx.moveTo(0, waveY);
                    ctx.quadraticCurveTo(200, waveY - 20, 400, waveY);
                    ctx.quadraticCurveTo(600, waveY + 20, 800, waveY);
                    ctx.stroke();
                }
            }

            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            for (let i = -1; i < 2; i++) {
                ctx.fillRect(0, (backgroundOffset + i * canvas.height) % canvas.height, canvas.width, 10);
            }

            ctx.fillStyle = 'gray';
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'black';
            walls.forEach(wall => {
                if (wall.y + wall.height > 0 && wall.y < canvas.height) {
                    ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                }
            });

            obstacles.forEach(obs => {
                if (obs.y + obs.height > 0 && obs.y < canvas.height) {
                    switch (obs.type) {
                        case 'Angel':
                            ctx.fillStyle = 'white';
                            ctx.fillRect(obs.x, obs.y + 10, obs.width, obs.height - 20);
                            ctx.beginPath();
                            ctx.moveTo(obs.x, obs.y + 10);
                            ctx.lineTo(obs.x - 20, obs.y + 30);
                            ctx.lineTo(obs.x + 20, obs.y + 30);
                            ctx.fill();
                            ctx.moveTo(obs.x + obs.width, obs.y + 10);
                            ctx.lineTo(obs.x + obs.width + 20, obs.y + 30);
                            ctx.lineTo(obs.x + obs.width - 20, obs.y + 30);
                            ctx.fill();
                            break;
                        case 'Harp':
                            ctx.fillStyle = 'gold';
                            ctx.beginPath();
                            ctx.moveTo(obs.x, obs.y + obs.height);
                            ctx.lineTo(obs.x + obs.width, obs.y);
                            ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
                            ctx.fill();
                            break;
                        case 'Gate':
                            ctx.fillStyle = 'white';
                            ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                            ctx.fillStyle = 'yellow';
                            ctx.fillRect(obs.x + obs.width / 2 - 5, obs.y - 10, 10, 10);
                            break;
                        case 'Bird':
                            ctx.fillStyle = 'gray';
                            ctx.beginPath();
                            ctx.arc(obs.x + obs.width / 2, obs.y + obs.height / 2, obs.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = 'white';
                            ctx.fillRect(obs.x + obs.width - 10, obs.y, 5, 5);
                            break;
                        case 'Meteor':
                            ctx.fillStyle = 'brown';
                            ctx.beginPath();
                            ctx.arc(obs.x + obs.width / 2, obs.y + obs.height / 2, obs.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = 'orange';
                            ctx.fillRect(obs.x, obs.y, 5, 5);
                            break;
                        case 'Airplane':
                            ctx.fillStyle = 'silver';
                            ctx.fillRect(obs.x, obs.y + 10, obs.width, obs.height - 20);
                            ctx.fillRect(obs.x + 20, obs.y, obs.width - 40, 10);
                            break;
                        case 'Rock':
                            ctx.fillStyle = 'darkgray';
                            ctx.beginPath();
                            ctx.moveTo(obs.x + obs.width / 2, obs.y);
                            ctx.lineTo(obs.x + obs.width, obs.y + obs.height / 4);
                            ctx.lineTo(obs.x + obs.width * 0.8, obs.y + obs.height);
                            ctx.lineTo(obs.x + obs.width / 4, obs.y + obs.height * 0.9);
                            ctx.lineTo(obs.x, obs.y + obs.height / 3);
                            ctx.closePath();
                            ctx.fill();
                            break;
                        case 'StoneDots':
                            ctx.fillStyle = 'darkgray';
                            ctx.beginPath();
                            ctx.arc(obs.x + obs.width / 2, obs.y + obs.height / 2, obs.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case 'Tent':
                            ctx.fillStyle = 'orange';
                            ctx.beginPath();
                            ctx.moveTo(obs.x, obs.y + obs.height);
                            ctx.lineTo(obs.x + obs.width / 2, obs.y);
                            ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
                            ctx.fill();
                            break;
                        case 'Climber':
                            ctx.fillStyle = 'blue';
                            ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                            ctx.fillStyle = 'red';
                            ctx.fillRect(obs.x + 5, obs.y - 5, 10, 5);
                            break;
                        case 'Car':
                            ctx.fillStyle = 'red';
                            ctx.fillRect(obs.x + 10, obs.y + 10, obs.width - 20, obs.height - 20);
                            ctx.fillStyle = 'black';
                            ctx.beginPath();
                            ctx.arc(obs.x + 15, obs.y + obs.height - 5, 10, 0, Math.PI * 2);
                            ctx.arc(obs.x + obs.width - 15, obs.y + obs.height - 5, 10, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = 'gray';
                            ctx.fillRect(obs.x + 20, obs.y, obs.width - 40, 10); // Tag
                            break;
                        case 'Pedestrian':
                            ctx.fillStyle = 'blue';
                            ctx.fillRect(obs.x, obs.y + 10, obs.width, obs.height - 10);
                            ctx.beginPath();
                            ctx.arc(obs.x + obs.width / 2, obs.y + 5, 5, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case 'Building':
                            ctx.fillStyle = 'gray';
                            ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                            for (let i = 0; i < 3; i++) {
                                ctx.fillStyle = 'yellow';
                                ctx.fillRect(obs.x + 10 + i * 15, obs.y + 10, 10, 10);
                            }
                            break;
                        case 'Fish':
                            ctx.fillStyle = 'blue';
                            ctx.beginPath();
                            ctx.arc(obs.x + obs.width / 2, obs.y + obs.height / 2, obs.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = 'white';
                            ctx.fillRect(obs.x + obs.width - 5, obs.y + 5, 3, 3);
                            break;
                        case 'Whale':
                            ctx.fillStyle = 'darkblue';
                            ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                            ctx.beginPath();
                            ctx.moveTo(obs.x + obs.width, obs.y + obs.height);
                            ctx.lineTo(obs.x + obs.width + 20, obs.y + obs.height + 10);
                            ctx.lineTo(obs.x + obs.width, obs.y + obs.height + 20);
                            ctx.fill();
                            break;
                        case 'Demon':
                            ctx.fillStyle = 'orange';
                            ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                            ctx.fillStyle = 'red';
                            ctx.beginPath();
                            ctx.arc(obs.x + 5, obs.y - 5, 5, 0, Math.PI * 2);
                            ctx.arc(obs.x + obs.width - 5, obs.y - 5, 5, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case 'Devil':
                            ctx.fillStyle = 'orange';
                            ctx.fillRect(obs.x, obs.y + 10, obs.width, obs.height - 20);
                            ctx.fillStyle = 'red';
                            ctx.beginPath();
                            ctx.moveTo(obs.x, obs.y + 10);
                            ctx.lineTo(obs.x - 20, obs.y + 30);
                            ctx.lineTo(obs.x + 20, obs.y + 30);
                            ctx.fill();
                            ctx.moveTo(obs.x + obs.width, obs.y + 10);
                            ctx.lineTo(obs.x + obs.width + 20, obs.y + 30);
                            ctx.lineTo(obs.x + obs.width - 20, obs.y + 30);
                            ctx.fill();
                            break;
                        case 'Flame':
                            let flameGradient = ctx.createLinearGradient(obs.x, obs.y, obs.x, obs.y + obs.height);
                            flameGradient.addColorStop(0, 'yellow');
                            flameGradient.addColorStop(1, 'red');
                            ctx.fillStyle = flameGradient;
                            ctx.beginPath();
                            ctx.moveTo(obs.x + obs.width / 2, obs.y);
                            ctx.quadraticCurveTo(obs.x + obs.width, obs.y + obs.height / 2, obs.x + obs.width, obs.y + obs.height);
                            ctx.quadraticCurveTo(obs.x + obs.width / 2, obs.y + obs.height * 0.8, obs.x, obs.y + obs.height);
                            ctx.quadraticCurveTo(obs.x + obs.width / 4, obs.y + obs.height / 2, obs.x + obs.width / 2, obs.y);
                            ctx.fill();
                            for (let i = 0; i < 3; i++) {
                                ctx.fillStyle = 'orange';
                                ctx.beginPath();
                                ctx.arc(obs.x + obs.width / 2 + (i - 1) * 5, obs.y + obs.height / 2, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            break;
                        default:
                            ctx.fillStyle = 'purple';
                            ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    }
                }
            });
            ctx.shadowBlur = 0;

            if (player.collisionBlink === 0 || Math.floor(Date.now() / 100) % 2 === 0) {
                let scale = player.jumping ? 1.2 : 1;
                let scaledWidth = player.width * scale;
                let scaledHeight = player.height * scale;
                let offsetX = (scaledWidth - player.width) / 2;
                let offsetY = (scaledHeight - player.height);

                ctx.save();
                ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                ctx.rotate(player.rotation);
                ctx.translate(-player.width / 2, -player.height / 2);

                ctx.fillStyle = 'black';
                ctx.fillRect(5 - offsetX, 0 - offsetY, (player.width - 10) * scale, (player.height - 20) * scale);
                ctx.fillStyle = 'gray';
                ctx.beginPath();
                ctx.arc(10 * scale - offsetX, 50 * scale - offsetY, 8 * scale, 0, Math.PI * 2);
                ctx.arc(30 * scale - offsetX, 50 * scale - offsetY, 8 * scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'silver';
                ctx.fillRect(15 * scale - offsetX, -10 * scale - offsetY, 10 * scale, 20 * scale);
                ctx.fillStyle = 'red';
                ctx.fillRect(18 * scale - offsetX, -15 * scale - offsetY, 4 * scale, 5 * scale);

                ctx.restore();
            }

            ctx.fillStyle = 'yellow';
            projectiles.forEach(proj => {
                if (proj.y + proj.height > 0 && proj.y < canvas.height) {
                    ctx.beginPath();
                    ctx.arc(proj.x + proj.width / 2, proj.y + proj.height / 2, proj.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.fillStyle = 'white';
            particles.forEach(p => {
                if (p.y + p.size > 0 && p.y < canvas.height) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Level: ${player.level}`, 10, 30);
            if (player.fullRun) {
                ctx.fillText(`Tid: ${player.fullRunTimer.toFixed(2)}s`, 10, 60);
                ctx.fillText(`Sværhed: ${difficulties[player.difficultyIndex]}`, 10, 90);
                ctx.fillText(`Liv: ${player.lives}`, 10, 120);
                ctx.fillText(`Dødsfald: ${player.deaths}`, 10, 150);
            }
            ctx.fillText(`Tid: ${timeElapsed.toFixed(2)}s`, 600, 30);
            ctx.fillText(`Hop Cooldown: ${player.jumpCooldown.toFixed(1)}s`, 10, player.fullRun ? 180 : 60);

            ctx.fillStyle = 'gray';
            ctx.fillRect(10, player.fullRun ? 200 : 80, 100, 20);
            ctx.fillStyle = 'green';
            ctx.fillRect(10, player.fullRun ? 200 : 80, player.energy, 20);
            ctx.fillStyle = 'black';
            ctx.font = '16px Arial';
            ctx.fillText('Energi', 10, player.fullRun ? 195 : 75);
        }
    </script>
</body>
</html>